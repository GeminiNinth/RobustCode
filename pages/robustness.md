---
layout: center
---

Any fool can write code that a computer can understand. 

Good programmers write code that humans can understand.

コンパイラが理解できるコードは馬鹿にだって書ける。

優れたプログラマは、人間にとってわかりやすいコードを書く。
<div style="text-align: right;">Martin Fowler</div>

---

# ロバストとは
いまいちど、ロバストとは何かを確認しておこう。

ロバストを調べると、以下の用語が出てくる。

> 1. 強さや健全性を有する、または誇示している。
> 2. 力、強度、硬度などを持っている、または示している。
> 3. しっかりと作られている、または組み立てられている
> 4. さまざまな条件の下で故障せずに動作する
> 
> [引用: https://www.merriam-webster.com/dictionary/robust]

これらが、目指すべきロバストなソフトウェアの目指すべき方向性。

→ 長きにわたって<b class="safe">健全</b>に動作し、変更に対して脆弱にならない<b class="safe">強度</b>を持ち、強固な基盤の上に<b class="safe">しっかりと作り上げられ</b>、<b class="safe">さまざまな条件のもとでも故障しない</b>強いシステムを構築すること。

---
layout: center
---

システムの強さとは、<b class="warn">鉄製の棒のような硬さ</b>に非ず。
<b class="safe">柳のような柔軟性</b>である。


長く使われるソフトウェアは大抵の場合、当初の構想から夢にも思わないような進化を遂げる。

要件の変更という強風に対しても<b class="safe">しなやかに対応できるようなコード</b>を書くことが重要。

---

## なぜロバストなコードを書くのか

プログラミング初学者用の教材の多くは、
コードの綺麗さでなく、正しい処理であるかだけしか見ない。

これ自体は悪いことではない。いちいち形式論を使って"お上品"にコーディングする事は、初学者にとってはハードルが高い上に、本質的でないため。

---

しかし、このまま「綺麗なコード」を書く意識が芽生えないと、以下のような未来につながりかねない。

1. ロバストでないコードこそが、手早く成果を出せる手段だと思い込む
1. 短命なコードしか書かないので、ロバストなコードを書く必要性を感じなくなる
1. そのまま研究室や会社に入り、長期的な開発プロジェクトに携わる
1. 手早く、その場しのぎで、独りよがりコードしか書かない
2. 要件の変更やバグ取りに対する<b class="warn">時間と労力が次第に増える</b>
3. 次第にプロジェクトが<b class="warn">炎上し始める</b>......

---

実際のところ、ロバストなコードを書くことは、短期的には時間がかかることが多い。

しかし、手軽で短命なコードで築きあげられた砂上の楼閣は、<b class="warn">少しの変更で崩れてしまう。</b>

あなたの能力が高いなら、つぎはぎだらけのコードでも何とかなるかもしれない。

しかしあなたの後任者は、過去のあなたの決断の上に立つ。

システムを崩壊させまいとし、ウサギの穴に落ちたり[^2]、ヤクの毛刈り[^3]に陥ったりして、どんどん仕事が遅れていってしまう。

[^2]: 本筋から外れて、複雑で難解な問題にはまり込むこと

[^3]: 元の問題に取り掛かる前に、それとは無関係だが解決しないとならない問題が次々に発生すること

---

### 長期的な開発をする上では、時間と労力をかけてでもロバストなコードを書くことが、最終的な時間と労力を節約することに繋がる。
<!-- <img src="/img/develop_time_effort.png"/> -->

<div class="center">
  <img src="/img/develop_time_effort.png" />
</div>
---

### 日常に潜むクソコード
新人のあなたが組織で最初にアサインされるのは、大抵の場合<b class="warn">ブラウンフィールドプロジェクト</b>

完全新規で1からアーキテクチャや設計、モジュール構造を決定できる<b class="safe">グリーンフィールドプロジェクト</b>に対し

ブラウンフィールドでは、<b class="warn">既存のコードを修正・拡張すること</b>が主な仕事

そのような状況で"他者"のコードに取り掛かる際、次のような<b class="warn">クソコード</b>に出会うことがある。

---

if文やfor文の連続。階段のようで美しいが、実際にこれを読み解く際は心中穏やかでない。

```python {*}{lines:true}
for i in range(n):
  if (条件):
    # 数十～数百行におよぶ処理

    if (条件):
      # 数十～数百行におよぶ処理

      if (条件):
        # 数十～数百行におよぶ処理

        if (条件):
          # 数十～数百行におよぶ処理

        # 数十～数百行におよぶ処理

      # 数十～数百行におよぶ処理

    # 数十～数百行におよぶ処理
```

---

ロジックが意味不明。たった3行のコードだが、理解するのに30分はかかりそうである。

```python {*}{lines:true}
if !a is not True and (b is True and ((c // 10 == 0 or d is not True) is True)) or (a is False and (b or not d) and (c % 10 == 0)):
  tmp = f(n, m) if m % 2 == 0 else f(n, m * 2)
  tmp += (lambda x: x**2 + 3 if x > 0 else x**3 - 2)(g(x)) if (x > 10 or x < -10) else (x / 2) * f(x)
```

---
layout: center
---

ブラウンフィールドに蓄積する、こうした意味の分からないコードの山は<b class="warn">レガシーコード</b>と呼ばれる。

### レガシーコードは<b class="warn">誰も触りたがらない</b>

### レガシーコードは<b class="warn">理解に時間がかかる</b>

### レガシーコードは<b class="warn">バグが見つけにくい</b>

<br>

### レガシーコードは<b class="warn">少しいじっただけでプロジェクトが大炎上する</b>

---

# コード品質の4つのゴール
ロバストコーディングへの道しるべ

Tom Longは、著書『Good Code, Bad Code』において、**コードを書く際に重要な4つのゴール**を以下のように述べている。

1. 正しく動く事
2. 正しく動作し続ける事
3. 要件の変更に対応しやすいこと
4. 車輪の再発明をしないこと

これらを詳しく見ていこう。

---

## 正しく動く事

自明なことだが、あえて言及する。

コードの一番の目的は「正しく動くこと」である。

バグの存在は適切な動作と完全な問題解決の妨げであり、「正しく動くこと」はすなわち、バグがないことを暗示する。

---

## 正しく動作し続ける事

コードが今日だけ一時的に正しく動いても、明日には動かなくなっていたら意味がない。
コードは独立した存在ではなく、注意しなければ周囲の変更によって簡単に壊れてしまう。

- コードは他のコードの修正や変更に依存する
- 新しい機能が必要になったとき、既存のコードを変更することが必要になる
- 解決したい問題は、ユーザーのニーズや技術的な問題で完全に変わることがある

今日動くコードでも、上記の項目のいずれかが変更することで、明日には動かなくなるのなら、意味が無い。

正しく動作するコードは<b class="safe">簡単に書ける</b>が、正しく動作し続けるコードを書くのは<b class="warn">非常に難しい</b>。

「<b class="safe">正しく動作し続けること</b>」を担保するコードを常に意識しよう。

---

## 要件の変更に対応しやすいこと

一度書かれたコードが、その後、一切の変更が加えられないということはまずありえない。

数年以上にわたって使われるコードは、その間に何度も要件が変わることがある。

<b class="warn">要件の変更に強いコードを作るのはそれだけ難しい</b>作業。

なぜなら、将来的にどんな変更が加わるのかを100%予測するのは難しいため。

そんな事が出来る人はプログラマーなんてやってないで、株式投資家や競馬で生計を立てている。

---

<div class="mid-text">
コードが<b class="warn">どのように変化するのか</b>という予測は出来ない。

さりとて<b class="warn">変化していくだろう</b>という実情は無視してはならない。

以下に、要件変更に対する極端な2つの姿勢を示す。

- <b class="warn">将来の変更を考えても無駄</b>だから、目の前の要件を実直に反映したコードを書く人。
  
    やがて変更対応を考慮しなかった負債が積み上がって、<b class="warn">大爆発</b>する

- どんな変更が加わるのかひたすら調査し、細部まで検討に検討を重ねる人。

    結局、地盤を固めることばかりやっている間に、<b class="warn">競合他社が市場を席巻</b>してしまう

どちらも両極端な姿勢だが、<b class="warn">いずれのシナリオも悲惨な結果につながってしまう</b>

両者の間にある<b class="safe">いずれかのポイントで妥協</b>することが必要になるが、問題は<b class="warn">答えが1つでない点</b>。

### → プロジェクトやチームの風土により、どのポイントで妥協するかが異なる

</div>

---
layout: center
---
幸運にも、将来どういった対応が必要になるか知らずとも

コードを<b class="safe">将来の変更に対応しやすくするためのテクニック</b>がある。

それも、いかなるプロジェクトにだって適用できるような<b class="safe">広く汎用的なテクニック</b>

---

## 車輪の再発明をしないこと

既に機能やライブラリが存在しているにも関わらず、新しく同じようなものを作り出してしまうことを<b class="warn">車輪の再発明</b>という

### 車輪の再発明自体は悪いことじゃない

アルゴリズムやライブラリを自分で実装することで技術に対する理解が深まるため、プログラミングの授業などの文脈では車輪の再発明は頻繁に行われる。

### しかし研究や開発における車輪の再発明は、時間と労力の無駄。


---

既に確立された技術よりも品質が劣るものを発明することを<b class="warn">四角い車輪の再発明</b>という。

四角い車輪は、未熟さゆえにバグやパフォーマンスの低さが問題となり、百害あって一利なし。

より円い車輪を開発することが主目的でないかぎり<b class="safe">既存のライブラリやフレームワークを利用</b>しよう。

「行列計算を行う機能」や「画像をグレースケールに変換する機能」、「ファイルやフォルダのパスを管理するための機能」を開発したいと思ったら、**黄色信号**。

あなたよりもずっと深い知見を有するエキスパートが、あなたが将来開発するであろうものよりもずっと優れたコードを既に提供しているかもしれない。

---

# コード品質を保つ6つの柱
具体的にすべきこと

[コード品質の4つのゴール](#コード品質の4つのゴール)は、私たちが達成しようとすることへ焦点を絞るのに役立つが、具体性には欠ける。

Tom Longは次に、より明確なアドバイスとして<b class="safe">コード品質を保つための6つの柱</b>を以下のように定義している。

1. コードを読みやすくする
2. 想定外の自体をなくす
3. 誤用しにくいコードを書く
4. コードをモジュール化する
5. コードを再利用、汎用化しやすくする
6. テストしやすいコードを書き、適切にテストする

---

## コードを読みやすくする
以下の文章を読んでみてほしい。

あえてクソ読みづらい文章となっているので、解読せずにサラっと目を通して大意を掴む程度でいい。

>ボウルを取る。これをAと呼ぶ。鍋を取る。これをBと呼ぶ。Bを水で満たし、コンロの上に置く。Aにチョコレートとバターを乗せる。前者は100グラム、後者は185グラムとすること。あとチョコレートはカコ70%のダークチョコレートにすること。Bの上にAを置く。Aの中身が溶けるまでほうちして、BからAを取り除く。新しくボウルを用意する。これをCと呼ぶ。Cに卵、砂糖、バニラエッセンスを入れる。最初のものは2個、2つ目のものは185グラム、3つ目のものはティースプーンの半分にすること。Cの中身を混ぜる。Aの中身が冷めたら、Cに移して混ぜる。新しくボウルを用意する。これをDと呼ぶ。Dに小麦粉、ココアパウダー、食塩を入れる。最初のものは50グラム、2つ目のものは35グラム、3つ目のものはティースプーンの半分にすること。Dの中身を徹底的に混ぜたら、ふるいにかけながらCに入れる。Dの中身がなじむようによくかき混ぜる。そういえば、私たちはチョコレートブラウニーを作っているんだけど、いってなかったっけ？Dを取り、70グラムのチョコレートチップを入れ、Dの中身を馴染むようによくかき混ぜる。焼き型を用意する。これをEと呼ぶ。Eにベーキングパウダーを塗って並べる。Dの中身をEに入れる。オーブンをFと呼ぶ。ちなみに、事前に160度で余熱しておかねばならない。EをFに入れて20分待ってから、Eを取り除く。Eを数時間冷やす。

---


### さて、問題です。

- これは何の文章？
- 全てを指示通りに行うと、何が完成する？
- どんな材料や器具をどれだけ用意したらいい？

---

文章中に全て答えはあるが、とにかく読みやすさが足りない。

読みづらさの原因は、以下の通り
- <b class="warn">タイトルがなく</b>、全てを読まないと<b class="warn">何を作るのかさえ分からない</b>
- ステップごとに分かれておらず、<b class="warn">ひとまとまりの文</b>で書かれている
- 「溶けたチョコレートとバターが入ったボウル」でなく「A」のように、漠然とした<b class="warn">役立たずな代名詞</b>が使われている
- <b class="warn">必要な情報が遠くに配置</b>されている。材料や量が別に書かれたり、作りたいものやオーブンの予熱などが最後の方に書かれている

---

ひどいコードというのは、このレシピと同様に読みづらい。

特にコードにおいては、以下の点で理解するのに苦労することとなる。

- 何をしているか
- どのようにするか
- 要素として何が必要か（入力と状態）
- このコードを実行すると、どんな結果が得られるのか

コードが読みづらいと、ロジックの理解に時間がかかったり、何をしているのか誤解したり、重要な詳細を見逃してしまうこともある。コードが正しく動いているのかさえも、判断がつかなくなる。そして、バグが見つからなくなる。

### どこかのコードに1つでもバグが紛れ込むだけで、プロジェクト全体のバグとなる。

料理のレシピと同様に、コードも読みやすいように書く必要がある。

---

## 想定外の事態をなくす

### 突然だけど、クイズです。

> Windows10のPCを使っていて、トラブルが発生した。どうやらキャッシュ関連が悪さをしているようで、挙動があまりにもおかしい。一度電源を落とす必要がありそうだ。

どの電源オプションを取るべき？
1. 「シャットダウン」を選択し、時間をおいてから電源をONする
2. 「再起動」を選択する
3. どっちも変わらないので好きな方を選ぶ

---
layout: center
---

1を選ぶ人は少なからずいるのではないだろうか？

「再起動」だと、PCの電源が真に落ちている感じがせず、なんだかキャッシュを受け継いでいそう。

「シャットダウン」だと完全に全てクリアされる気がする。

---
layout: center
---

## 正解は**2**の「再起動」。

（次ページのスライドで解説します。本筋に関係ないので、興味が無ければ飛ばしてOK）

---
layout: two-cols
---

Windows10では"<b class="safe">高速スタートアップ機能</b>"が既定で有効。

シャットダウン時にキャッシュを保存しておき、次回起動時にそのキャッシュを使って高速起動を行う。

不具合さえもキャッシュに保存されてしまうため、シャットダウンしても不具合が解消されないことがある。

よく考えてみると「再起動」、すなわち「電源を落としてすぐに起動しなおす」という行動は、大抵の場合大きなアップデートを施した後に行うもの。

→ 再起動を行うことでシステムのリフレッシュが行われ、不具合の原因となっているキャッシュもクリアされる可能性が高い。

トラブルが発生した場合は、「再起動」を選ぼう。

<!-- [参考](https://x.com/MSHelpsJP/status/1030008766757044224) -->

::right::

<div class="center">
<Tweet id="1030008766757044224"/>
</div>

---

「シャットダウン」を選択していた人にとって、
当初の想定と実際の動作とで、仕様が真逆になっていることが分かった。

開発者が気を利かせてくれたがゆえの動作だと納得はいくが、ユーザーにとっては「<b class="warn">想定外の事態</b>」であったことに違いない。

### これを<b class="warn">驚き</b>と呼ぶ。

---

### <b class="warn">驚き</b>は、コードにおいても起こりうる。

- Aをする関数だと思って利用したら、実際はBをする関数だった
- Cだけをしたくて関数を実行したのに、Cだけでなく勝手にDもEもFもやられた


---

### 驚きは、<b class="warn">バグの原因</b>となる。

コードの動作を予測できないため。

### 驚きは、<b class="warn">ストレス</b>となる。

予測が覆され続けるため。

コードを書くあなたと、それを読む"他者"の認識差が生む<b class="safe">驚きをできるだけ減らす</b>ことが望ましい。

> **驚き最小の原則**: コードの動作が読み手に与える驚きを、最小限に抑える設計原則

---

## 誤用しにくいコードを書く
"<b class="safe">誤用しにくい</b>"とは？

→ <b class="safe">防御的設計原則</b>を意識したコード

> **防御的設計原則（ポカヨケ）**: ミスを防ぐ（ポカを避ける）仕組み

総機の皆さんなら工業機械の操作におけるポカヨケをご存知ですよね？？

---

### 両手を用いないとプレス機を操作できない

  <div class="middle-center">
    <img src="/img/press_machine.png" />
  </div>

（[画像引用](https://aismiley.co.jp/ai_news/pokayoke/)）

---

### ソケットとプラグの形状が異なると接続できない[^4]

  <!-- ![socket](img/Comparision-of-USB-Plug-Sizes.webp) -->
  <div class="small-center">
    <img src="/img/Comparision-of-USB-Plug-Sizes.webp" />
  </div>

  （[画像引用](https://www.diodes.com/design/support/perspective/the-complexities-of-usb-type-c-and-how-to-handle-them/)）

[^4]: ただしMicro-BとMicro-BのSuperSpeedや、TypeBと第三世代TypeBには後方互換性がある

---

ポカヨケにより、操作ミスや誤接続を防げる。

ソフトウェアでも同様

### <b class="safe">使いやすく、誤用しにくくあるべき</b>（EUHM, easy to use and hard to misuse）


---

## コードをモジュール化する

モジュール性をもたせたコードは<b class="safe">変更に強い</b>

モジュール性とは、物やシステムが<b class="safe">交換可能な、より小さいコンポーネント</b>にまとめられることを指す。

---
layout: image-right
image: https://www.techniekenwetenschapsacademie.be/wp-content/uploads/2020/03/STEM-Peer.png
---

右のような玩具はモジュール化の最たる例。

様々な形状の<b class="safe">独立</b>したブロック

組み合わせに応じて<b class="safe">様々な形状</b>の構造物

一部のパーツが欠損しても、<b class="safe">その部分のパーツだけ補充</b>

規格化された穴にブロックをはめ込むだけで、<b class="safe">簡単に組み立て</b>

<b class="safe">気に入らない部分だけ交換</b>するのも簡単

[画像引用: https://www.amazon.co.jp/WYSWYG-%E3%83%AC%E3%82%B4%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E8%BF%BD%E5%8A%A0-%E5%9F%BA%E7%A4%8E%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%BB%E3%83%83%E3%83%88-2%E6%AD%B3%E3%81%8B%E3%82%89%E3%81%AE%E7%A9%8D%E3%81%BF%E6%9C%A8-%E7%9F%A5%E8%82%B2%E7%8E%A9%E5%85%B7%EF%BC%8881%E3%83%94%E3%83%BC%E3%82%B9/dp/B0CVZQ66V8?th=1]

---
layout: image-right
image: https://www.lightup.jp/on/demandware.static/-/Sites-lightup-master-catalog/default/dw1018f743/large-2/6/63/639606-l01.jpg
---

<!-- image: /img/bear.jpg -->
一方、こちらの玩具はモジュール化されていない。

腕に油汚れがついて落とせなくなったとき...

<b class="warn">新しい腕に交換するのはどれだけ大変？</b>

あちこちに<b class="warn">縫い付けられた糸</b>を探し出す

腕を切断し、新たな腕を<b class="warn">縫い付ける</b>

誤って足と胴体を縫い付ける糸を切ってしまったら<b class="warn">大惨事</b>

[画像引用: https://www.lightup.jp/detail/639606.html]

---

ソフトウェアのシステムに関しても同様。

システムを<b class="warn">巨大な関数として書き連ねる</b>のではなく

機能ごとに<b class="safe">自己完結型のモジュールに分割</b>する。

### → 機能を変更時、あちこちに散らばる関連処理を探し出して修正するような事がない。

---

## コードを再利用、汎用化しやすくする
再利用性と汎用性は、似て非なる概念である。

- <b class="safe">再利用性</b>: 特定のあるものが複数のシナリオに出てくる同じ問題の解決に利用できること。
  
  "ドリルを用いて壁や床、天井に貫通穴を開ける"という事例を考える。

  - ドリル: 特定のあるもの
  - 壁や床、天井: 複数のシナリオ
  - 貫通穴を開ける: 同じ問題の解決
- <b class="safe">汎用性</b>: 特定のあるものが、微妙に異なるものの、概念的には似ている複数の問題に解決に利用できること。
  
  "ドリルを用いてネジ穴や貫通穴を開ける"という事例を考える

  - ドリル: 特定のあるもの
  - ネジ穴、貫通穴: 微妙に異なるもの
  - 穴を開ける: 概念的には似ている複数の問題

---

以下の4つの異なるドリルが必要な場合を考えよう。

1. 床に向かって垂直に持ったときしか貫通穴が開けられないドリル
2. 壁に向かって垂直に持ったときしか貫通穴が開けられないドリル
3. 天井に向かって垂直に持ったときしか貫通穴が開けられないドリル
4. ネジ穴しか開けられないドリル

私たちは、あらゆるDIYを行うためにも、これらの4つのドリルを購入する必要がある。
穴を開けるという1つ目的のために、なぜこんなにも苦労しないといけないのだろうか？

多額の費用がかかるし、持ち運びが大変だ。バッテリーも4つ充電しておかないといけない。

再利用しやすく汎用的なドリルがあれば、1つで全ての作業をこなすことができるはず。

コードにおいても同様。

---

### <b class="safe">再利用性と汎用性に富むコード</b>は、様々な場所やシナリオにおいて、<b class="safe">多くの解決策</b>を提供

そして、**<b class="safe">コードのモジュール化が再利用性と汎用性を高める</b>**。

---

## テストしやすいコードを書き、適切にテストする

テストは、バグや壊れた機能を含んだままのコードをリリースすることを防ぐための手段

寿命の長いコードベースでは、どうしても以下のような事態が発生する。

- コードベースが肥大化し、やがて一人のエンジニアで<b class="warn">全てのコードを把握することが難しく</b>なる。

- どんな天才エンジニアだって<b class="warn">間違いを犯す</b>

- コードの保守を担当することになった"他者"には<b class="warn">どう動けば適切で、どう動くとバグかも分からない。</b>

### プロジェクト炎上への火種を消すのが<b class="safe">テスト</b>

---

<div class="small-text">
  
## "他者"
常に"<b class="warn">他者</b>"の存在を前提としたコーディングを心掛けよう。

1. **あなたにとって明確なことでも<b class="warn">"他者"にとっては明確ではない</b>**
    
    あなたのコードがどう使われるべきで、何をして、なぜそれを行うのか。
    ただコメントを書けばいいというわけではない。コードを理解しやすくする方法がたくさんある。
4. **"他者"は<b class="warn">不注意であなたのコードを壊しうる</b>**

    あなたの書いたコードはあなたが良く知る世界だが、<b class="warn">あなたが組織を去った後もコードは残り続ける</b>。
    後任者はあなたの事も、あなたのコードも知らないので、<b class="warn">あなたのコードを壊してしまう可能性が大きい</b>

    何かを間違えたときに以下の挙動を徹底するほかない。
    - コードが走らないようにする（コンパイルできないようにする）
    - テストを通過できないようにする
7. **"他者"には<b class="warn">3日後のあなたも含まれる</b>**

    本資料で"他者"と表現するのは、それが将来の自分も含むから。

    人は愚かです。人はすぐに忘れてしまいます。
    多少時間をかけてでも丁寧なコードを書くことは、<b class="safe">将来の自分を助ける</b>ことにもなる。

</div>